#define MSG_ORIENT_HOR 1
#define MSG_ORIENT_VER 2
#define MSG_ZERO_POS 3
#define MSG_ABS_STEP 4
#define MSG_ABS_VISIBLE 5
#define MSG_ABS_DASHES_STEP 6
#define MSG_REL_VISIBLE 7
#define MSG_REL_START 8
#define MSG_REL_END 9
#define MSG_REL_DASHES 10
#define MSG_REDRAW 11

#define RULER(typeName,imageName,xDragOn,yDragOn,xSliderSize,ySliderSize) \
group { \
   images { \
      image: imageName COMP; \
   } \
   name:"ui/ruler/"typeName"/default"; \
   parts { \
      part { \
         name: "background"; \
         type: RECT; \
         description { \
            state: "default" 0.0; \
            color: 255 255 255 255; \
       } \
         description { \
            state: "hidden" 0.0; \
            inherit: "default" 0.0; \
            visible: 0; \
         } \
         description { \
            state: "displayed" 0.0; \
            inherit: "default" 0.0; \
            visible: 1; \
         } \
      } \
      part { \
      name: "cliper"; \
         type: RECT; \
         description { \
            state: "default" 0.0; \
            rel1.to: "background"; \
            rel2.to: "background"; \
         } \
      } \
      part { \
         name: "lua"; \
         type: GROUP; \
         source: "ruler/lua"; \
         clip_to: "cliper"; \
         description{ \
            state: "default" 0.0; \
         } \
      } \
      part { \
         name: "pointer"; \
         type: IMAGE; \
         scale: 1; \
         mouse_events: 1; \
         dragable { \
            x: xDragOn 1 0; \
            y: yDragOn 1 0; \
            confine: "background"; \
         } \
         description { \
            state: "default" 0.0; \
            image.normal: imageName; \
            aspect_preference: SOURCE; \
            min: xSliderSize ySliderSize; \
            max: xSliderSize ySliderSize; \
            rel1 { \
               to: "background"; \
            } \
            rel2 { \
               to: "background"; \
            } \
         } \
      } \
   } /*parts*/ \
   programs { \
      program { \
         name: "ruler_background_hide"; \
         signal: "ruler,bg,hide"; \
         source: ""; \
         action: STATE_SET "hidden" 0.0; \
         target: "background"; \
      } \
      program { \
         name: "ruler_background_show"; \
         signal: "ruler,bg,show"; \
         source: ""; \
         action: STATE_SET "displayed" 0.0; \
         target: "background"; \
      } \
   } \
}/*group*/

RULER("horizontal","ruler_hor_pointer.png",1,0,10,15);

RULER("vertical","ruler_ver_pointer.png",0,1,15,10);

group {
   name: "ruler/lua";
   lua_script_only: 1;
   lua_script {
      --//options
      local calcStep = false;
      local horizontal = true;
      local absVisible = true;
      local relVisible = false;
      --//vars for edje objects
      local absDashes={};
      local relDashes={};
      local absLabels={};
      local relLabels={};
      local line;
      local label;
      --//dashes and labels count used to display ruler. can be less than array size
      local absDashesNeeded;
      local relDashesNeeded=3;
      local absLabelsNeeded;
      local relLabelsNeeded=3;
      --//position of relative 0.0 and 1.0
      local relStart = 0;
      local relEnd = 600;
      --//value step (if min&max values are calculated) and position of zero mark(in pixels)
      local valueStep = 50;
      local zeroPos = 0;
      --//step between dashes(in pixels)
      local absStep = 5;
      --//small dashes at begining
      local startDashes=0;
      --//widget size
      local height;
      local width;

      --//debug funcs
      function print_table_start(table, space, name)
         print(space .. name .. ": ");
         print(space .. "{");
         print_table(table, space .. "  ");
         print(space .. "}");
      end

      function print_table(table, space)
         for k, v in pairs(table) do
            if type(v) == "table" then
               print_table_start(v, space, k);
            elseif type(v) == "string" then
               print(space .. k .. ': "' .. v .. '";')
            else
               print(space .. k .. ": " .. v .. ";")
            end
         end
      end
      --//end debug funcs

      --//creating or hiding marks and dashes if needed(for abs scale)
      function prepareAbs()
         if(calcStep) then
            startDashes=0;
         else
            startDashes=(zeroPos-zeroPos%absStep)/absStep;
         end
         if(horizontal) then
            absDashesNeeded=(width-width%absStep)/absStep;
         else
            absDashesNeeded=(height-height%absStep)/absStep;
         end
         absLabelsNeeded=(absDashesNeeded-startDashes%10-(absDashesNeeded-startDashes%10)%10)/10+1;
         if(absVisible==false) then
            absLabelsNeeded=0;
            absDashesNeeded=0;
         end

         while #absDashes<absDashesNeeded do
            line=edje.line();
            line:color(0,0,0,255);
            line:show();
            table.insert(absDashes,line);
         end
         while #absLabels<absLabelsNeeded+1 do
            label=edje.text();
            label:color(0,0,0,255);
            label:font("Sans",8);
            label:show();
            table.insert(absLabels,label);
         end
         for i=1,absDashesNeeded do
            absDashes[i]:show();
         end
         for i=1,absLabelsNeeded do
            absLabels[i]:show();
         end
         for i=absDashesNeeded+1,#absDashes do
            absDashes[i]:hide();
         end
         for i=absLabelsNeeded+1,#absLabels do
            absLabels[i]:hide();
         end
      end

      --//creating or hiding marks and dashes if needed(for rel scale)
      function prepareRel()
         while #relDashes<relDashesNeeded do
            line=edje.line();
            line:color(50,150,50,255);
            line:show();
            table.insert(relDashes,line);
         end
         while #relLabels<relLabelsNeeded do
            label=edje.text();
            label:color(50,150,50,255);
            label:font("Sans",8);
            label:show();
            table.insert(relLabels,label);
         end
         if(relVisible) then
            for i=1,relDashesNeeded do
               relDashes[i]:show();
            end
            for i=1,relLabelsNeeded do
               relLabels[i]:show();
            end
            for i=relDashesNeeded+1,#relDashes do
               relDashes[i]:hide();
            end
            for i=relLabelsNeeded+1,#relLabels do
               relLabels[i]:hide();
            end
         else
            for i=1,#relDashes do
               relDashes[i]:hide();
            end
            for i=1,#relLabels do
               relLabels[i]:hide();
            end
         end
      end

      --//placing dashes and marks (if widget size or step changed)
      function positionChange()
        local j=1;
         if(horizontal) then
             --//y coords for major/minor dashes
            local dash10y1 = height/2;
            local dashRely = 2*height/5;
            local dashy2 = height;
            local dash5y1 = 3*height/4;
            local dash1y1 = 9*height/10;
            local xShift = zeroPos%absStep;
            --//abs scale
            for i=0, absDashesNeeded-1 do
               if((i-startDashes)%10==0) then
                  absDashes[i+1]:xy(xShift+absStep*i,dash10y1,xShift+absStep*i,dashy2);
                  absDashes[i+1]:move(xShift + absStep*i,dash10y1);
                  absLabels[j]:geom(xShift + absStep*i+2, dash10y1-2,xShift+absStep*(i+5),dash5y1);
                  j=j+1;
               elseif((i-startDashes)%5==0) then
                  absDashes[i+1]:xy(xShift + absStep*i,dash5y1,xShift+absStep*i,dashy2);
                  absDashes[i+1]:move(xShift + absStep*i,dash5y1);
                  --//FIXME: we need to move line to its start position because xy() places it relative to canvas coord (not widget coords). This is probably a bug
               else
                  absDashes[i+1]:xy(xShift + absStep*i,dash1y1,xShift+absStep*i,dashy2);
                  absDashes[i+1]:move(xShift + absStep*i,dash1y1);
               end
               absLabels[j]:geom(xShift+absStep*absDashesNeeded+2,dash10y1-2,xShift+absStep*(absDashesNeeded+5),dash5y1);
            end
            --//rel scale
            local relStep=(relEnd-relStart)/(relDashesNeeded-1);
            for i=0, relDashesNeeded-1 do
                  relDashes[i+1]:xy(relStart+relStep*i,0,relStart+relStep*i,dashRely);
                  relDashes[i+1]:move(relStart + relStep*i,0);
                  relLabels[i+1]:geom(relStart + relStep*i+2,0,relStart+relStep*(i+5),dash5y1);
            end
         else
            --//x coords for major/minor dashes
            local dash10x1 = width/2;
            local dashRelx = 2*width/5;
            local dashx2 = width;
            local dash5x1 = width/4 + dash10x1;
            local dash1x1 = 3*width/8 + dash10x1;
            local yShift = zeroPos%absStep;
            --//abs scale
            for i=0, absDashesNeeded-1 do
               if((i-startDashes)%10==0) then
                  absDashes[i+1]:xy(dash10x1,yShift+absStep*i,dashx2,yShift+absStep*i);
                  absDashes[i+1]:move(dash10x1,yShift+absStep*i);
                  absLabels[j]:geom(0,yShift+absStep*i, dash1x1,yShift+ absStep*(i+2));
                  j=j+1;
               elseif((i-startDashes)%5==0) then
                  absDashes[i+1]:xy(dash5x1,yShift+absStep*i,dashx2,yShift+absStep*i);
                  absDashes[i+1]:move(dash5x1,yShift+absStep*i);
               else
                  absDashes[i+1]:xy(dash1x1,yShift+absStep*i,dashx2,yShift+absStep*i);
                  absDashes[i+1]:move(dash1x1,yShift+absStep*i);
               end
            end
            absLabels[j]:geom(0,yShift+absStep*absDashesNeeded, dash1x1,yShift+ absStep*(absDashesNeeded+2));
             --//rel scale
            local relStep=(relEnd-relStart)/(relDashesNeeded-1);
            for i=0, relDashesNeeded-1 do
                  relDashes[i+1]:xy(0,relStart+relStep*i,dashRelx,relStart+relStep*i);
                  relDashes[i+1]:move(0,relStart + relStep*i);
                  relLabels[i+1]:geom(0,relStart + relStep*i+2,dash1x1,relStart+relStep*(i+5));
            end
         end
      end

      --//redraw dashes and labels
      function draw()
         --//print "redraw";
         prepareRel();
         prepareAbs();
         positionChange();
         valuesChange();
      end

      --//changing values near marks (if range or dashes count changed)
      function valuesChange()
         if(calcStep) then
            valueStep=(maxValue-minValue)/(absDashesNeeded/10);
         else
            local smallDashes=(zeroPos-zeroPos%absStep)/absStep;
            local bigDashes=(smallDashes-smallDashes%10)/10;
            minValue = -bigDashes * valueStep;
         end
         for i=1,absLabelsNeeded do
            absLabels[i]:text(string.format("%.0f",minValue+(i-1)*valueStep));
         end

         for i=1,relDashesNeeded do
            relLabels[i]:text(string.format("%.2f",(i-1)/(relDashesNeeded-1)));
         end
      end

      --//onresize
      function resize(w,h)
         width=w;
         height=h;
         --print("resized (" .. w .. "x" .. h ..")");
         draw();
      end

      --//onmove
      function move (x, y)
         --print("lua::move x=" .. x .. " x=" .. y);
         draw();
      end

      --//interaction with C part
      function message (id, type, ...)
         --print("lua::message id=" .. id .. " type=" .. type);
         if("float" == type) then
            if(id == 1) then
               minValue=...;
               valuesChange();
            elseif(id==2) then
               maxValue=...;
               valuesChange();
            end
         elseif("none"==type) then
            if(id==MSG_ORIENT_HOR) then
               horizontal=true;
               --//draw(); //commented out due performance issues
            elseif(id==MSG_ORIENT_VER) then
               horizontal=false;
            elseif(id==MSG_REDRAW) then
               draw();
            end
         elseif("int" == type) then
            if(id==MSG_ZERO_POS) then
               zeroPos= ...;
               --//draw();
            elseif(id==MSG_ABS_STEP) then
               valueStep = ...;
               --//draw();
            elseif(id==MSG_ABS_VISIBLE) then
               if(... == 1) then
                  absVisible=true;
               else
                  absVisible=false; --// 0!=false
               end
               draw();
            elseif(id==MSG_ABS_DASHES_STEP) then
               absStep=...;
               --//draw();
            elseif(id==MSG_REL_VISIBLE) then
               if( ... == 1) then
                  relVisible=true;
               else
                  relVisible=false;
               end
               draw();
            elseif(id==MSG_REL_START) then
               relStart=...;
               --//draw();
            elseif(id==MSG_REL_END) then
               relEnd= ...;
               --//draw();
            elseif(id== MSG_REL_DASHES) then
               relDashesNeeded= ... +1;
               relLabelsNeeded= ... +1;
               --//draw();
            end
         end
      end
   }//lua_script
}//group
